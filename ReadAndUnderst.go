/*
1. Что выведет программа? Объяснить вывод программы.

package main

import (
    "fmt"
)

func main() {
    a := [5]int{76, 77, 78, 79, 80}
    var b []int = a[1:4]
    fmt.Println(b)
}
_______________________________________________________________________________________________________________
ОТВЕТ:
ПРОГРАММА ВЫВЕДЕТ: [77 78 79]

ПОЯСНЕНИЕ:
копирование части элементов массива a[5]int в срез b[]int.
Переносим часть элементов, конкретного отрезка массива – значения с индексами с 1 по 3.
Т.к. 4 – это не номер элемента, а сумма первого числа и общего количества элементов.
Т.е. копируем с 1 элемента + 3 элемента = 4
ИЛИ
копирование до n-го элемента, не включая этот элемент.
_______________________________________________________________________________________________________________
_______________________________________________________________________________________________________________
2. Что выведет программа? Объяснить вывод программы.
Объяснить как работают defer’ы и их порядок вызовов.

package main

import (
    "fmt"
)


func test() (x int) {
    defer func() {
        x++
    }()
    x = 1
    return
}


func anotherTest() int {
    var x int
    defer func() {
        x++
    }()
    x = 1
    return x
}


func main() {
    fmt.Println(test())
    fmt.Println(anotherTest())
}
_______________________________________________________________________________________________________________
ОТВЕТ:
ПРОГРАММА ВЫВЕДЕТ:
2
1

ПОЯСНЕНИЕ:
1) Функция test() выводит результат 2,
т.к. defer выполняется непосредственно перед return => после присвоения х значения == 1,
вызывается анонимная функция, увеличивающая значение х на 1, поэтому в результате получаем 2.
ВАЖНО: в данном случае, переменная x int – не вычислена до функции defer => она будет вычисляться, после x = 1.
2) Функция anotherTest() выводит результат 1,
т.к. на момент вызова defer, переменная x – вычислена и == 0 => отработав,
анонимная функция вернёт значение x++ (или 0 + 1). Поэтому в данном случае – defer не будет работать корректно.

DEFER:
это функция отложенного вызова, которая указывает внутренней функции на выполнение, перед выходом из внешней;
выполняется независимо от потока следующих функций; может использоваться в любом месте;
можно вызвать несколько defer-функций; как правило используется для освобождения ресурсов.
Правила работы с defer:
1) Последний отложенный вызов будет вызван первым;
2) Отложенные функции могут читать и устанавливать именованные возвращаемые значения внешней функции;
3) Аргументы отложенного вызова функции вычисляются тогда, когда вычисляется команда defer.
_______________________________________________________________________________________________________________
_______________________________________________________________________________________________________________
3. Что выведет программа?
Объяснить вывод программы.
Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.

package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}
_______________________________________________________________________________________________________________
ОТВЕТ:
ПРОГРАММА ВЫВЕДЕТ:
<nil>
false

ПОЯСНЕНИЕ:
os.PathError – возвращает ошибку (конкретику) после проверки соответствия интерфейсов.
Если он не совпадают – вернёт конкретизацию ошибки, если совпадают – вернёт <nil>,
ВАЖНО: не пустой интерфейс => выражение err == nil, всегда будет ложным.

ВНУТРЕННЕЕ УСТРОЙСТВО ИНТЕРФЕЙСОВ/ОТЛИЧИЯ ОТ ПУСТЫХ ИНТЕРФЕЙСОВ:
1) Интерфейс хранит поведение;
2) Сам тип интерфейса хранит в себе указатель на структуру (tab), а так же переменную,
содержащую фактическую переменную с конкретным типом (data).
3) В отличие от обычного, «пустой» интерфейс, подходит для любого типа,
т.к. он не хранит в себе никаких методов => не описывает никакого поведения.
_______________________________________________________________________________________________________________
_______________________________________________________________________________________________________________
4. Что выведет программа? Объяснить вывод программы.

package main

import "sync"

func main() {
	wg := sync.WaitGroup{}

	wg.Add(1)

	ch := make(chan int)

	go func() {
		defer close(ch)
		//defer wg.Done()
		for i := 0; i < 10; i++ {
			ch <- i
		}
	}()

	for n := range ch {

		println(n)
	}
	wg.Wait()

}
_______________________________________________________________________________________________________________
ОТВЕТ:
ПРОГРАММА ВЫВЕДЕТ:
0
1
2
3
4
5
6
7
8
9
fatal error: all goroutines are asleep - deadlock!

ПРОБЛЕМЫ:
1) Анонимная функция запущена в горутине, а main – не ждёт её завершения. Необходимо добавить WaitGroup;
2) Функция, записывающая данные в канал, не закрывает его => цикл, считывая данные из канала, ожидает поступления новых, чем блокирует канал, т.к. горутина, «пишущая» в канал, больше ничего в него отправлять не собирается.

РЕШЕНИЕ:

package main

import "sync"

func main() {
    wg := sync.WaitGroup{}

    wg.Add(1)

    ch := make(chan int)

    go func() {
        defer close(ch)
        defer wg.Done()
        for i := 0; i < 10; i++ {
            ch <- i
        }
    }()

    for n := range ch {

        println(n)
    }
    wg.Wait()

}
_______________________________________________________________________________________________________________
_______________________________________________________________________________________________________________
5. Что выведет программа? Объяснить вывод программы.

package main

type customError struct {
     msg string
}

func (e *customError) Error() string {
    return e.msg
}

func test() *customError {
     {
         // do something
     }
     return nil
}

func main() {
    var err error
    err = test()
    if err != nil {
        println("error")
        return
    }
    println("ok")
}
_______________________________________________________________________________________________________________
ОТВЕТ:

ПРОГРАММА ВЫВЕДЕТ:
error

ПОЯСНЕНИЕ:
1) Функция test() возвращает *customError => после её работы тип переменной определён + как результат,
у нас сформирован адрес в памяти. А указанный nil в return – это то,
что будет храниться по этому адресу (неважно nil или существующий объект);
2) Создавая var err error мы задаём тип переменной err = error, со значением равным nil.
После отработки метода err = test(), err становится указателем на область памяти,
содержащий *customError (а это уже nil), а поэтому err не может стать nil.

РЕШЕНИЕ:
1) Создаём указатель на тип customError;
2) При помощи функции test(), записываем значение nil по адресу этой переменной:

package main

type customError struct {
    msg string
}

func (e *customError) Error() string {
    return e.msg
}

func test() *customError {
    {
        // do something
    }
    return nil
}

func main() {
    var err = (new(customError))
    err = test()
    if err != nil {
        println("error")
        return
    }
    println("ok")
}
_______________________________________________________________________________________________________________
_______________________________________________________________________________________________________________
6. Что выведет программа? Объяснить вывод программы.
Рассказать про внутреннее устройство слайсов и что происходит при передачи их в качестве аргументов функции.

package main

import (
  "fmt"
)

func main() {
  var s = []string{"1", "2", "3"}
  modifySlice(s)
  fmt.Println(s)
}

func modifySlice(i []string) {
  i[0] = "3"
  i = append(i, "4")
  i[1] = "5"
  i = append(i, "6")
}
_______________________________________________________________________________________________________________
ОТВЕТ:

ПРОГРАММА ВЫВЕДЕТ:
[3 2 3]

ПРОБЛЕМЫ:
1) Т.к. срез описывает массив (т.е. содержит указатель на массив, длину и ёмкость среза), то при передаче его,
в качестве аргумента функции, мы, фактически передаём эту ссылку на исходный массив с определённой диной
(т.к. он инициализирован до передачи в функцию) => места на оставшиеся элементы, добавленные с помощью append,
в этом массиве нет, поэтому он так же и остаётся из 3-х элементов.
2) После использования первого append в функции modifySlice(), мы получаем первый «новый» срез,
созданный из исходного, то далее в теле функции начинаем работать с ним и не меняем исходный.
Т.е. код функции:
i[0] = "3"
i = append(i, "4")
i[1] = "5"
i = append(i, "6")
даёт результат: [3,2,3]
то код:
i[0] = "3"
i[1] = "5"
i = append(i, "4")
i = append(i, "6")
даёт результат: [3,5,3]
т.к. до первого append, мы работали с «исходным» срезом/массивом.

РЕШЕНИЕ: работать со срезом, с помощью указателя:

package main

import (
    "fmt"
)

func main() {
    var s = &[]string{"1", "2", "3"}
    modifySlice(s)
    fmt.Println(s)
}

func modifySlice(i *[]string) {
    (*i)[0] = "3"
    (*i) = append((*i), "4")
    (*i)[1] = "5"
    (*i) = append((*i), "6")
}
Результат: [3 5 3 4 6]
_______________________________________________________________________________________________________________
_______________________________________________________________________________________________________________
7. Что выведет программа? Объяснить вывод программы.

package main

import (
	"fmt"
	"math/rand"
	"time"
)

func asChan(vs ...int) <-chan int {
	c := make(chan int)

	go func() {
		for _, v := range vs {
			c <- v
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
		}

		close(c)
	}()
	return c
}

func merge(a, b <-chan int) <-chan int {
	c := make(chan int)
	go func() {
		for {
			select {
			case v := <-a:
				c <- v
			case v := <-b:
				c <- v
			}
		}
	}()
	return c
}

func main() {

	a := asChan(1, 3, 5, 7)
	b := asChan(2, 4, 6, 8)
	c := merge(a, b)
	for v := range c {
		fmt.Println(v)
	}
}
_______________________________________________________________________________________________________________
ОТВЕТ:
ПРОГРАММА ВЫВЕДЕТ:
1
2
3
4
5
6
7
8
0 – бесконечное количество.

ОПИСАНИЕ ПРОГРАММЫ:
1) Функция asChan() – принимает в качестве аргумента срез int, возвращая канал для чтения, типа int. Для этого, в горутине перебирает массив, полученный в качестве аргумента, и записывает полученные данные в возвращаемый канал.
2) Функция merge() - принимает в качестве аргумента 2 канала «для чтения» типа int, возвращая 1 канал для чтения типа int. Для этого, в бесконечном цикле записывает в возвращаемый канал, данные, полученные из каналов, переданных настоящей функции в качестве аргументов.

ПРОБЛЕМА: в функции merge():
1) Т.к. цикл бесконечен => в возвращаемый канал считываются значения до «бесконечности», а если их в исходном канале не существует – в итоговый записываются нули;
2) Итоговый канал не закрыт, что может вызвать deadlock.

РЕШЕНИЕ:
1) Ограничить длину итогового массива;
2) Закрыть канал после записи:
func merge(a, b <-chan int) <-chan int {
    c := make(chan int)
    go func() {
        for x := range a {
            c <- x
        }
        for z := range b {
            c <- z
        }
        close(c)
    }()
    return c
}*/